This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-26 12:50:47

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
.python-version
LICENSE
pyproject.toml
README.md
requirements.txt
src
  prompt_deck
    context_input.py
    file_drop_area.py
    file_placeholder.py
    prompt_deck.py
    styles.py
    __init__.py
    __main__.py
```

# Repository Files


## .gitignore

- Characters: 108
- Tokens: 0

```text
# Python-generated files
__pycache__/
*.py[oc]
build/
dist/
wheels/
*.egg-info

# Virtual environments
.venv
```

## .python-version

- Characters: 4
- Tokens: 0

```text
3.10
```

## LICENSE

- Characters: 1060
- Tokens: 0

```text
MIT License

Copyright (c) 2025 yada

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## pyproject.toml

- Characters: 475
- Tokens: 0

```text
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "prompt-deck"
version = "0.1.0"
description = "A lightweight Windows utility for structuring LLM prompts"
readme = "README.md"
authors = [
    { name = "yada", email = "trojblue@gmail.com" }
]
requires-python = ">=3.8"
license = "MIT"
dependencies = [
    "PyQt6>=6.6.1",
    "keyboard>=0.13.5",
    "appdirs>=1.4.4",
]

[project.scripts]
prompt-deck = "prompt_deck.prompt_deck:main"
```

## README.md

- Characters: 2036
- Tokens: 0

````markdown
# Prompt Deck

A lightweight Windows utility for efficiently structuring LLM prompts. The application provides a convenient interface that stays docked in the upper-right corner of your screen and can be quickly accessed when needed.

## Features

- **Auto-hide Functionality**: Automatically hides when not in use and reappears when you move your cursor to the top-left corner
- **Global Hotkey**: Toggle the application with Ctrl+U
- **Persistent Storage**: All prompts and context inputs are saved between sessions
- **Dynamic Context Fields**: Add multiple labeled context sections as needed
- **One-Click Actions**: Quickly copy formatted prompts and launch popular LLM websites
- **Character Counter**: Track the length of your context inputs

## Installation

1. Ensure you have Python 3.8 or higher installed
2. Clone this repository
3. Install the required dependencies:

```bash
pip install -r requirements.txt
```

## Usage

1. Run the application:
```bash
python src/prompt_deck.py
```

2. The application will appear in the top-right corner of your screen

3. Use the following controls:
   - Press Ctrl+U to show/hide the application
   - Move your cursor to the top-left corner to show the application
   - Click "Add Context" to add new context sections
   - Use the "Copy to Clipboard" button to copy your formatted prompt
   - Use the LLM site shortcuts to quickly launch your favorite AI assistants

4. The application will automatically save your prompts and window position between sessions

## Keyboard Shortcuts

- **Ctrl+U**: Show/Hide the application
- **Tab**: Navigate between input fields
- **Esc**: Clear field focus
- **Enter**: Multi-line input in text areas

## LLM Site Shortcuts

The application includes quick-launch buttons for:
- ChatGPT
- Claude
- Grok

Clicking these buttons will copy your prompt and open the respective website.

## Data Storage

Your prompts and application settings are stored in:
- Windows: `%LOCALAPPDATA%\PromptDeck\`

## License

MIT License - See LICENSE file for details
````

## requirements.txt

- Characters: 44
- Tokens: 0

```text
PyQt6>=6.6.1
keyboard>=0.13.5
appdirs>=1.4.4
```

## src\prompt_deck\context_input.py

- Characters: 7584
- Tokens: 0

````python
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QTextEdit, QPushButton, QLabel
from PyQt6.QtGui import QFont
from .styles import FONT_FAMILY, name_input_style, content_input_style

from typing import Dict
from pathlib import Path

from .styles import name_input_style, content_input_style, delete_button_style, add_context_btn_style

class ContextInput(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)

        # Track if we have a file loaded
        self.file_name = None
        self.setup_ui()

        # Enable drag-and-drop on this widget
        self.setAcceptDrops(True)

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 2, 10, 2)  # Added 10px right margin
        layout.setSpacing(2)

        # "Notes" input (was "Context Name")
        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText("Context Notes")
        self.name_input.setFont(QFont(FONT_FAMILY, 10))
        self.name_input.setStyleSheet(name_input_style)
        layout.addWidget(self.name_input)

        # Content input / text area
        self.content_input = QTextEdit()
        self.content_input.setFixedHeight(150)  # Increased from 80 to 150
        self.content_input.setPlaceholderText("Content")
        self.content_input.setFont(QFont(FONT_FAMILY, 10))
        self.content_input.textChanged.connect(self.update_char_count)
        modified_content_style = content_input_style + "padding-right: 5px;"
        self.content_input.setStyleSheet(modified_content_style)
        layout.addWidget(self.content_input)

        # Bottom row (unchanged)
        bottom_row = QHBoxLayout()
        bottom_row.setSpacing(5)

        # Character count label
        self.char_count_label = QLabel("Characters: 0")
        self.char_count_label.setFont(QFont(FONT_FAMILY, 8))
        self.char_count_label.setStyleSheet("color: #7f8c8d; font-style: italic;")
        bottom_row.addWidget(self.char_count_label)

        bottom_row.addStretch()

        # "Add File" button
        self.file_button = QPushButton("Add File")
        self.file_button.setFixedWidth(80)
        self.file_button.setFont(QFont(FONT_FAMILY, 9))
        self.file_button.clicked.connect(self.on_add_file_clicked)
        # You can reuse or alter any style you prefer
        self.file_button.setStyleSheet(add_context_btn_style)
        bottom_row.addWidget(self.file_button)

        # Delete button
        self.delete_button = QPushButton("Remove")
        self.delete_button.setFixedWidth(80)
        self.delete_button.setFont(QFont(FONT_FAMILY, 9))
        self.delete_button.clicked.connect(self.on_delete)
        self.delete_button.setStyleSheet(delete_button_style)
        bottom_row.addWidget(self.delete_button)

        layout.addLayout(bottom_row)

    #
    # File logic
    #
    def on_add_file_clicked(self):
        """Open a file dialog to load file contents into the text box."""
        from PyQt6.QtWidgets import QFileDialog
        path, _ = QFileDialog.getOpenFileName(self, "Select a File", "", "All Files (*)")
        if path:
            self.load_file(path)

    def load_file(self, filepath: str):
        """Read file contents, store them in the text area, and remember the file name."""
        try:
            file_text = Path(filepath).read_text(encoding="utf-8", errors="replace")
            self.file_name = Path(filepath).name  # Just the filename
            
            # Update the "notes" section with the filename
            self.name_input.setText(self.file_name)
            
            self.content_input.setPlainText(file_text)
            self.update_char_count()
        except Exception as e:
            print(f"Error reading file: {e}")

    #
    # Drag-and-drop overrides
    #
    def dragEnterEvent(self, event):
        """Accept a file if dragged into the widget."""
        if event.mimeData().hasUrls():
            # Check if at least one of them is a local file
            urls = event.mimeData().urls()
            if len(urls) > 0 and urls[0].isLocalFile():
                event.acceptProposedAction()
                
                # Highlight effect for this context input
                current_style = self.styleSheet()
                self.setStyleSheet(current_style + """
                    ContextInput {
                        background-color: rgba(232, 245, 233, 0.5);
                        border: 2px dashed #4CAF50;
                        border-radius: 5px;
                    }
                """)
        else:
            super().dragEnterEvent(event)
            
    def dragLeaveEvent(self, event):
        """Reset styling when drag leaves."""
        # Restore original styling
        self.setStyleSheet("")
        super().dragLeaveEvent(event)

    def dropEvent(self, event):
        """When a file is dropped, load its contents."""
        urls = event.mimeData().urls()
        if urls and urls[0].isLocalFile():
            filepath = urls[0].toLocalFile()
            
            # Flash a confirmation style briefly
            self.setStyleSheet("""
                ContextInput {
                    background-color: rgba(232, 245, 233, 0.8);
                    border: 2px solid #4CAF50;
                    border-radius: 5px;
                }
            """)
            
            # Reset after a short delay
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(500, lambda: self.setStyleSheet(""))
            
            self.load_file(filepath)
            event.acceptProposedAction()
        else:
            super().dropEvent(event)

    #
    # Existing methods
    #
    def on_delete(self):
        """Removes itself from the layout and the main list."""
        self.setParent(None)
        self.deleteLater()

    def update_char_count(self):
        count = len(self.content_input.toPlainText())
        self.char_count_label.setText(f"Characters: {count}")

    def get_data(self) -> Dict[str, str]:
        """
        Return the "notes" in `name`
        and the final content in `content`.

        If a file was loaded, format it as:

            {file_name}
            ```text
            {file_contents}
            ```
        Otherwise, just return whatever is in the text box.
        """
        notes = self.name_input.text()
        raw_text = self.content_input.toPlainText()

        if self.file_name:
            # Construct the special format for file-based context
            content = f"{self.file_name}\n```text\n{raw_text}\n```"
        else:
            # Manual text mode
            content = raw_text

        return {
            "name": notes,      # "Context Notes"
            "content": content  # Possibly file-based
        }

    def set_data(self, data: Dict[str, str]):
        """
        Load previously saved content.
        If it looks like file-based content, parse it out (optional).
        """
        # We'll do a simple approach: if we detect the pattern with "```",
        # we assume a file was previously loaded. This is optional.
        # You can parse more precisely if needed.

        notes = data.get("name", "")
        content_str = data.get("content", "")

        self.file_name = None  # Reset

        # Optional: if the content pattern matches the file-based approach
        # (filename + ```...), we could parse it. For simplicity, we'll just set the text.
        self.name_input.setText(notes)
        self.content_input.setText(content_str)
        self.update_char_count()
````

## src\prompt_deck\file_drop_area.py

- Characters: 3503
- Tokens: 0

```python
from PyQt6.QtWidgets import QWidget, QLabel, QVBoxLayout
from PyQt6.QtCore import Qt, pyqtSignal
from PyQt6.QtGui import QFont, QPalette, QColor, QDragEnterEvent, QDropEvent

from .styles import FONT_FAMILY

class FileDropArea(QWidget):
    """A drop area that accepts files and emits a signal with the file path"""
    
    # Signal emitted when a file is dropped
    fileDropped = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Create a label with instructions
        self.label = QLabel("Drop Files")
        self.label.setFont(QFont(FONT_FAMILY, 9))
        self.label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Style the widget to look like a button
        self.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                border: 1px dashed #95a5a6;
                border-radius: 4px;
            }
            QWidget:hover {
                background-color: #e0e0e0;
                border: 1px dashed #7f8c8d;
            }
        """)
        
        layout.addWidget(self.label)
        
    def dragEnterEvent(self, event: QDragEnterEvent):
        # Accept the drag event if it has URLs (files)
        if event.mimeData().hasUrls() and len(event.mimeData().urls()) > 0:
            if event.mimeData().urls()[0].isLocalFile():
                event.acceptProposedAction()
                # Highlight the drop area
                self.setStyleSheet("""
                    QWidget {
                        background-color: #e8f5e9;
                        border: 1px dashed #66bb6a;
                        border-radius: 4px;
                    }
                """)
        
    def dragLeaveEvent(self, event):
        # Reset styling when drag leaves
        self.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                border: 1px dashed #95a5a6;
                border-radius: 4px;
            }
            QWidget:hover {
                background-color: #e0e0e0;
                border: 1px dashed #7f8c8d;
            }
        """)
        
    def dropEvent(self, event: QDropEvent):
        # When a file is dropped, emit a signal with the file path
        urls = event.mimeData().urls()
        if urls and urls[0].isLocalFile():
            filepath = urls[0].toLocalFile()
            self.fileDropped.emit(filepath)
            
            # Flash a confirmation style briefly
            self.setStyleSheet("""
                QWidget {
                    background-color: #e8f5e9;
                    border: 1px solid #66bb6a;
                    border-radius: 4px;
                }
            """)
            
            # Reset after a short delay
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(500, lambda: self.setStyleSheet("""
                QWidget {
                    background-color: #f0f0f0;
                    border: 1px dashed #95a5a6;
                    border-radius: 4px;
                }
                QWidget:hover {
                    background-color: #e0e0e0;
                    border: 1px dashed #7f8c8d;
                }
            """))
            
            event.acceptProposedAction()
```

## src\prompt_deck\file_placeholder.py

- Characters: 2052
- Tokens: 0

```python
from PyQt6.QtWidgets import QWidget, QLabel, QVBoxLayout
from PyQt6.QtCore import Qt, QSize
from PyQt6.QtGui import QFont, QIcon, QPainter, QPixmap

from .styles import FONT_FAMILY

class FilePlaceholder(QWidget):
    """
    A nicer placeholder widget for the empty context state that shows
    a document icon and instructions for dropping files.
    """
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
    
    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 30, 20, 30)
        layout.setSpacing(15)
        layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        # Get standard file icon
        self.icon_label = QLabel()
        file_icon = QIcon(QIcon.fromTheme("document", 
                         QIcon.fromTheme("text-x-generic")))
                          
        # If system themes aren't available, try to use Qt's standard icons
        if file_icon.isNull():
            from PyQt6.QtWidgets import QApplication, QStyle
            file_icon = QIcon(QApplication.style().standardIcon(QApplication.style().StandardPixmap.SP_FileIcon))
        
        pixmap = file_icon.pixmap(QSize(48, 48))
        self.icon_label.setPixmap(pixmap)
        self.icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.icon_label)
        
        # Instruction text
        self.text_label = QLabel("Add context or drop files here")
        self.text_label.setFont(QFont(FONT_FAMILY, 12))
        self.text_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.text_label.setStyleSheet("color: #95a5a6;")
        layout.addWidget(self.text_label)
        
        # Style the widget with a subtle border
        self.setStyleSheet("""
            FilePlaceholder {
                background-color: #f8f9fa;
                border: 2px dashed #e0e0e0;
                border-radius: 8px;
            }
        """)
        
        # Set fixed size for better appearance
        self.setMinimumHeight(150)
```

## src\prompt_deck\prompt_deck.py

- Characters: 15934
- Tokens: 0

```python
import sys
import json
from pathlib import Path
from typing import Dict
import webbrowser

from appdirs import user_data_dir

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout,
    QHBoxLayout, QTextEdit, QLineEdit, QPushButton,
    QLabel, QScrollArea, QFrame, QSizePolicy
)
from PyQt6.QtCore import (
    Qt, QSize
)
from PyQt6.QtGui import (
    QFont, QIcon, QColor, QPalette
)

from .styles import FONT_FAMILY
from .styles import ui_style, add_context_btn_style, copy_btn_style, main_prompt_style, get_llm_button_style

from .context_input import ContextInput
from .file_drop_area import FileDropArea  # We'll create this class


class PromptDeck(QMainWindow):
    def __init__(self):
        super().__init__(None, Qt.WindowType.Window)
        self.setWindowTitle("Prompt Deck")

        # Use a nicer system icon for a more professional look
        self.setWindowIcon(QIcon(QApplication.style().standardIcon(QApplication.style().StandardPixmap.SP_FileDialogContentsView)))
        
        # Enable drag and drop for the entire window
        self.setAcceptDrops(True)
        
        # Variable to track highlight state
        self.is_drag_active = False
        self.original_stylesheet = ""

        # Setup UI
        self.setup_ui()
        self.load_state()

    def setup_ui(self):
        # Set the application style - more elegant, muted color palette
        self.setStyleSheet(ui_style)

        # Main widget and layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(10)

        # Main prompt
        prompt_layout = QVBoxLayout()
        prompt_layout.setSpacing(4)

        # Improved label styling
        prompt_label = QLabel("Main Prompt")
        prompt_label.setFont(QFont(FONT_FAMILY, 11, QFont.Weight.Medium))
        prompt_label.setStyleSheet("color: #2c3e50; margin-bottom: 4px;")
        prompt_layout.addWidget(prompt_label)

        # Improved text edit styling
        self.main_prompt = QTextEdit()
        self.main_prompt.setMinimumHeight(40)
        self.main_prompt.setPlaceholderText("Enter your main prompt here...")
        self.main_prompt.setFont(QFont(FONT_FAMILY, 10))
        self.main_prompt.setStyleSheet(main_prompt_style)
        prompt_layout.addWidget(self.main_prompt)

        main_layout.addLayout(prompt_layout)

        # Add a subtle separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        separator.setStyleSheet("background-color: #e8e8e8; margin: 8px 0;")
        main_layout.addWidget(separator)

        # Contexts row
        context_section = QHBoxLayout()
        context_label = QLabel("Context Sections")
        context_label.setFont(QFont(FONT_FAMILY, 11, QFont.Weight.Medium))
        context_label.setStyleSheet("color: #2c3e50;")
        context_section.addWidget(context_label)
        context_section.addStretch()

        # Removed file drop area - entire window will be a drop area instead

        # Improved button styling
        add_context_btn = QPushButton("Add Context")
        add_context_btn.setFixedWidth(100)
        add_context_btn.setFont(QFont(FONT_FAMILY, 9))
        add_context_btn.clicked.connect(self.add_context)
        add_context_btn.setStyleSheet(add_context_btn_style)
        context_section.addWidget(add_context_btn)

        main_layout.addLayout(context_section)

        # Scroll area
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setFrameShape(QFrame.Shape.NoFrame)
        self.scroll.setSizePolicy(
            QSizePolicy.Policy.Expanding,
            QSizePolicy.Policy.Expanding
        )

        self.context_container = QWidget()
        self.context_container.setStyleSheet("background-color: #fafafa;")
        self.context_layout = QVBoxLayout(self.context_container)
        self.context_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.context_layout.setContentsMargins(0, 0, 0, 0)
        self.context_layout.setSpacing(10)
        
        # Add placeholder for empty context (better visual)
        from .file_placeholder import FilePlaceholder
        self.placeholder = FilePlaceholder()
        self.context_layout.addWidget(self.placeholder)

        self.scroll.setWidget(self.context_container)
        main_layout.addWidget(self.scroll)

        # Keep track of contexts
        self.contexts = []

        # Don't add default context - just show placeholder
        # self.add_context()

        # Add a separator before buttons
        separator2 = QFrame()
        separator2.setFrameShape(QFrame.Shape.HLine)
        separator2.setFrameShadow(QFrame.Shadow.Sunken)
        separator2.setStyleSheet("background-color: #e8e8e8; margin: 8px 0;")
        main_layout.addWidget(separator2)

        # Button row with better organization
        button_layout = QHBoxLayout()
        button_layout.setSpacing(10)  # Add better spacing between buttons

        # Copy to clipboard
        self.copy_btn = QPushButton("Copy to Clipboard")
        self.copy_btn.setFont(QFont(FONT_FAMILY, 10))
        self.copy_btn.clicked.connect(self.copy_to_clipboard)
        self.copy_btn.setStyleSheet(copy_btn_style)
        button_layout.addWidget(self.copy_btn)

        # LLM site shortcuts with more elegant, muted styling
        self.llm_sites = {
            "ChatGPT": ("https://chat.openai.com", "#34495e"),  # Dark slate
            "Claude":  ("https://claude.ai", "#ec6b2d"),        # Claude orange
            "Grok":    ("https://x.com/i/grok", "#333333")         # Dark gray (not pure black)
        }

        for name, (url, color) in self.llm_sites.items():
            btn = QPushButton(name)
            btn.setFixedWidth(80)
            btn.setFont(QFont(FONT_FAMILY, 10))
            btn.clicked.connect(lambda checked, u=url: self.launch_site(u))
            btn.setStyleSheet(get_llm_button_style(color))
            button_layout.addWidget(btn)

        main_layout.addLayout(button_layout)

        # More refined window size with better proportions
        self.resize(520, 600)

    def add_context(self):
        # Check if placeholder exists and remove it
        if hasattr(self, 'placeholder') and self.placeholder is not None:
            self.placeholder.setVisible(False)
            self.placeholder = None
            
        context = ContextInput()
        context.delete_button.clicked.connect(
            lambda: self.remove_context(context)
        )
        self.contexts.append(context)
        self.context_layout.addWidget(context)
        return context

    def handle_file_drop(self, filepath):
        """Create a new context and load the file into it"""
        context = self.add_context()
        context.load_file(filepath)

    def remove_context(self, context):
        if context in self.contexts:
            self.contexts.remove(context)
            
        # If no contexts left, show placeholder again
        if not self.contexts:
            if not hasattr(self, 'placeholder') or self.placeholder is None:
                from .file_placeholder import FilePlaceholder
                self.placeholder = FilePlaceholder()
                self.context_layout.addWidget(self.placeholder)

    def copy_to_clipboard(self):
        formatted_text = self.get_formatted_text()
        clipboard = QApplication.clipboard()
        clipboard.setText(formatted_text)

    def launch_site(self, url: str):
        self.copy_to_clipboard()
        webbrowser.open(url)

    def get_formatted_text(self) -> str:
        parts = [self.main_prompt.toPlainText(), ""]

        valid_contexts = [
            c for c in self.contexts
            if c.parent() is not None and
               (c.get_data()["name"] or c.get_data()["content"])
        ]
        for context in valid_contexts:
            data = context.get_data()
            parts.extend([
                f"{data['name']}:",
                data["content"],
                ""
            ])

        return "\n".join(parts)

    def get_state(self) -> Dict:
        valid_contexts = [
            c for c in self.contexts
            if c.parent() is not None
        ]
        return {
            "main_prompt": self.main_prompt.toPlainText(),
            "contexts": [c.get_data() for c in valid_contexts],
            "geometry": {
                "x": self.x(),
                "y": self.y(),
                "width": self.width(),
                "height": self.height()
            }
        }

    def load_state(self):
        state_file = Path(user_data_dir("PromptDeck")) / "state.json"
        if state_file.exists():
            try:
                with open(state_file) as f:
                    state = json.load(f)
                # Main prompt
                self.main_prompt.setText(state.get("main_prompt", ""))

                # Remove default contexts and placeholder
                if hasattr(self, 'placeholder') and self.placeholder is not None:
                    self.placeholder.setVisible(False)
                    self.placeholder = None
                
                for c in self.contexts:
                    c.setParent(None)
                self.contexts.clear()

                # Load from file
                contexts_data = state.get("contexts", [])
                if contexts_data:
                    for context_data in contexts_data:
                        context = ContextInput()
                        context.set_data(context_data)
                        context.delete_button.clicked.connect(
                            lambda: self.remove_context(context)
                        )
                        self.contexts.append(context)
                        self.context_layout.addWidget(context)
                else:
                    # If no contexts in saved state, show placeholder
                    if not hasattr(self, 'placeholder') or self.placeholder is None:
                        from .file_placeholder import FilePlaceholder
                        self.placeholder = FilePlaceholder()
                        self.context_layout.addWidget(self.placeholder)

                # Geometry
                geometry = state.get("geometry", {})
                if geometry:
                    self.setGeometry(
                        geometry.get("x", 0),
                        geometry.get("y", 0),
                        geometry.get("width", 500),
                        geometry.get("height", 600)
                    )
            except Exception as e:
                print(f"Error loading state: {e}")

    def save_state(self):
        state_dir = Path(user_data_dir("PromptDeck"))
        state_dir.mkdir(parents=True, exist_ok=True)
        state_file = state_dir / "state.json"

        try:
            with open(state_file, "w") as f:
                json.dump(self.get_state(), f)
        except Exception as e:
            print(f"Error saving state: {e}")

    #
    # Drag and Drop implementation for the entire window
    #
    def dragEnterEvent(self, event):
        # Accept the drag event if it has URLs (files)
        if event.mimeData().hasUrls() and len(event.mimeData().urls()) > 0:
            if event.mimeData().urls()[0].isLocalFile():
                event.acceptProposedAction()
                
                # Store original stylesheet if not already stored
                if not self.is_drag_active:
                    self.original_stylesheet = self.context_container.styleSheet()
                    self.is_drag_active = True
                
                # Check if placeholder is visible and apply special styling
                if hasattr(self, 'placeholder') and self.placeholder and self.placeholder.isVisible():
                    self.placeholder.setStyleSheet("""
                        FilePlaceholder {
                            background-color: rgba(232, 245, 233, 0.7);
                            border: 2px dashed #4CAF50;
                            border-radius: 8px;
                        }
                    """)
                else:
                    # Regular highlight effect for content container
                    self.context_container.setStyleSheet("background-color: rgba(232, 245, 233, 0.5); border: 2px dashed #4CAF50; border-radius: 5px;")
    
    def dragLeaveEvent(self, event):
        # Reset styling when drag leaves
        if self.is_drag_active:
            if hasattr(self, 'placeholder') and self.placeholder and self.placeholder.isVisible():
                self.placeholder.setStyleSheet("""
                    FilePlaceholder {
                        background-color: #f8f9fa;
                        border: 2px dashed #e0e0e0;
                        border-radius: 8px;
                    }
                """)
            else:
                self.context_container.setStyleSheet("background-color: #fafafa;")
            self.is_drag_active = False
    
    def dropEvent(self, event):
        # When a file is dropped, create a new context with it
        urls = event.mimeData().urls()
        if urls and urls[0].isLocalFile():
            filepath = urls[0].toLocalFile()
            
            # Temporarily flash the confirmation style
            if hasattr(self, 'placeholder') and self.placeholder and self.placeholder.isVisible():
                self.placeholder.setStyleSheet("""
                    FilePlaceholder {
                        background-color: rgba(232, 245, 233, 0.8);
                        border: 2px solid #4CAF50;
                        border-radius: 8px;
                    }
                """)
            else:
                self.context_container.setStyleSheet("background-color: rgba(232, 245, 233, 0.8); border: 2px solid #4CAF50; border-radius: 5px;")
            
            # Now create the context and load the file
            self.handle_file_drop(filepath)
            
            # Reset after a short delay
            from PyQt6.QtCore import QTimer
            QTimer.singleShot(500, lambda: self.context_container.setStyleSheet("background-color: #fafafa;"))
            self.is_drag_active = False
            
            event.acceptProposedAction()
    
    def closeEvent(self, event):
        # Save state before closing
        self.save_state()
        event.accept()


def main() -> None:
    app = QApplication(sys.argv)
    # Apply a clean modern style for the whole application
    app.setStyle("Fusion")

    # Create a custom palette for a refined, elegant look
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(250, 250, 250))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(44, 62, 80))  # Darker slate blue
    palette.setColor(QPalette.ColorRole.Base, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(248, 248, 248))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(44, 62, 80))
    palette.setColor(QPalette.ColorRole.Text, QColor(44, 62, 80))
    palette.setColor(QPalette.ColorRole.Button, QColor(245, 245, 245))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(44, 62, 80))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Link, QColor(108, 139, 175))  # Muted blue
    palette.setColor(QPalette.ColorRole.Highlight, QColor(108, 139, 175))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))
    app.setPalette(palette)

    # Create and show the main window
    window = PromptDeck()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
```

## src\prompt_deck\styles.py

- Characters: 5042
- Tokens: 0

```python
FONT_FAMILY = "Inter, Segoe UI, -apple-system, BlinkMacSystemFont, Roboto, Oxygen, Ubuntu, Cantarell, sans-serif"

# Function to adjust colors programmatically for hover/pressed states
def adjust_color(hex_color, percent):
    """
    Adjusts a hex color by percent.
    Negative percent darkens, positive lightens.
    """
    hex_color = hex_color.lstrip('#')
    r = int(hex_color[0:2], 16)
    g = int(hex_color[2:4], 16)
    b = int(hex_color[4:6], 16)
    
    # Adjust colors
    r = max(0, min(255, int(r * (1 + percent/100))))
    g = max(0, min(255, int(g * (1 + percent/100))))
    b = max(0, min(255, int(b * (1 + percent/100))))
    
    return f'#{r:02x}{g:02x}{b:02x}'

ui_style = """
            QMainWindow {
                background-color: #fafafa;
            }
            QScrollArea {
                background-color: #fafafa;
                border: none;
            }
            QScrollBar:vertical {
                border: none;
                background: #f5f5f5;
                width: 6px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #d0d0d0;
                min-height: 20px;
                border-radius: 3px;
            }
            QScrollBar::handle:vertical:hover {
                background: #c0c0c0;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """
name_input_style = """
            QLineEdit {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 6px;
                background-color: white;
            }
            QLineEdit:focus {
                border: 1px solid #6c8baf;
                background-color: white;
            }
        """
content_input_style = """
            QTextEdit {
                border: 1px solid #e0e0e0;
                border-radius: 4px;
                padding: 6px;
                background-color: white;
            }
            QTextEdit:focus {
                border: 1px solid #6c8baf;
                background-color: white;
            }
        """

# Base colors
delete_color = "#e74c3c"
add_context_color = "#6c8baf"
copy_color = "#6c8baf"

delete_button_style = f"""
            QPushButton {{
                background-color: {delete_color};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px;
                opacity: 0.8;
            }}
            QPushButton:hover {{
                background-color: {adjust_color(delete_color, -10)};
                opacity: 0.9;
            }}
            QPushButton:pressed {{
                background-color: {adjust_color(delete_color, -20)};
            }}
        """
main_prompt_style = """
            QTextEdit {
                border: 1px solid #e0e0e0;
                border-radius: 6px;
                padding: 10px;
                background-color: white;
            }
            QTextEdit:focus {
                border: 1px solid #6c8baf;
                background-color: white;
                box-shadow: 0 0 4px rgba(108, 139, 175, 0.25);
            }
        """
add_context_btn_style = f"""
            QPushButton {{
                background-color: {add_context_color};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px;
            }}
            QPushButton:hover {{
                background-color: {adjust_color(add_context_color, -10)};
            }}
            QPushButton:pressed {{
                background-color: {adjust_color(add_context_color, -20)};
            }}
        """
copy_btn_style = f"""
            QPushButton {{
                background-color: {copy_color};
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px;
            }}
            QPushButton:hover {{
                background-color: {adjust_color(copy_color, -10)};
            }}
            QPushButton:pressed {{
                background-color: {adjust_color(copy_color, -20)};
            }}
        """

# LLM site shortcuts with updated, more distinctive colors
llm_sites = {
    "ChatGPT": ("https://chat.openai.com", "#34495e"),  # Dark slate
    "Claude":  ("https://claude.ai", "#ec6b2d"),        # Claude orange
    "Grok":    ("https://grok.x.ai", "#333333")         # Dark gray (not pure black)
}

def get_llm_button_style(color):
    """Generate button style for LLM shortcuts with programmatic hover effects"""
    return f"""
        QPushButton {{
            background-color: {color};
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px;
        }}
        QPushButton:hover {{
            background-color: {adjust_color(color, -10)};
        }}
        QPushButton:pressed {{
            background-color: {adjust_color(color, -20)};
        }}
    """
```

## src\prompt_deck\__init__.py

- Characters: 208
- Tokens: 0

```python
"""Prompt Deck - A lightweight Windows utility for structuring LLM prompts."""

__version__ = "0.1.0"

from .prompt_deck import main  # noqa: F401

# def main() -> None:
#     print("Hello from prompt-deck!")
```

## src\prompt_deck\__main__.py

- Characters: 90
- Tokens: 0

```python
import sys
from prompt_deck.prompt_deck import main

if __name__ == "__main__":
    main()
```

## Statistics

- Total Files: 13
- Total Characters: 38140
- Total Tokens: 0
