This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-26 11:40:52

# File Summary

## Purpose:

This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format:

The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
   a. A header with the file path (## File: path/to/file)
   b. The full contents of the file in a code block

## Usage Guidelines:

- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes:

- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Information:

For more information about Repomix, visit: https://github.com/andersonby/python-repomix


# Repository Structure

```
.gitignore
.python-version
LICENSE
pyproject.toml
README.md
requirements.txt
src
  prompt_deck
    prompt_deck.py
    __init__.py
    __main__.py
```

# Repository Files


## .gitignore

- Characters: 108
- Tokens: 0

```text
# Python-generated files
__pycache__/
*.py[oc]
build/
dist/
wheels/
*.egg-info

# Virtual environments
.venv
```

## .python-version

- Characters: 4
- Tokens: 0

```text
3.10
```

## LICENSE

- Characters: 1060
- Tokens: 0

```text
MIT License

Copyright (c) 2025 yada

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

## pyproject.toml

- Characters: 475
- Tokens: 0

```text
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "prompt-deck"
version = "0.1.0"
description = "A lightweight Windows utility for structuring LLM prompts"
readme = "README.md"
authors = [
    { name = "yada", email = "trojblue@gmail.com" }
]
requires-python = ">=3.8"
license = "MIT"
dependencies = [
    "PyQt6>=6.6.1",
    "keyboard>=0.13.5",
    "appdirs>=1.4.4",
]

[project.scripts]
prompt-deck = "prompt_deck.prompt_deck:main"
```

## README.md

- Characters: 2036
- Tokens: 0

````markdown
# Prompt Deck

A lightweight Windows utility for efficiently structuring LLM prompts. The application provides a convenient interface that stays docked in the upper-right corner of your screen and can be quickly accessed when needed.

## Features

- **Auto-hide Functionality**: Automatically hides when not in use and reappears when you move your cursor to the top-left corner
- **Global Hotkey**: Toggle the application with Ctrl+U
- **Persistent Storage**: All prompts and context inputs are saved between sessions
- **Dynamic Context Fields**: Add multiple labeled context sections as needed
- **One-Click Actions**: Quickly copy formatted prompts and launch popular LLM websites
- **Character Counter**: Track the length of your context inputs

## Installation

1. Ensure you have Python 3.8 or higher installed
2. Clone this repository
3. Install the required dependencies:

```bash
pip install -r requirements.txt
```

## Usage

1. Run the application:
```bash
python src/prompt_deck.py
```

2. The application will appear in the top-right corner of your screen

3. Use the following controls:
   - Press Ctrl+U to show/hide the application
   - Move your cursor to the top-left corner to show the application
   - Click "Add Context" to add new context sections
   - Use the "Copy to Clipboard" button to copy your formatted prompt
   - Use the LLM site shortcuts to quickly launch your favorite AI assistants

4. The application will automatically save your prompts and window position between sessions

## Keyboard Shortcuts

- **Ctrl+U**: Show/Hide the application
- **Tab**: Navigate between input fields
- **Esc**: Clear field focus
- **Enter**: Multi-line input in text areas

## LLM Site Shortcuts

The application includes quick-launch buttons for:
- ChatGPT
- Claude
- Grok

Clicking these buttons will copy your prompt and open the respective website.

## Data Storage

Your prompts and application settings are stored in:
- Windows: `%LOCALAPPDATA%\PromptDeck\`

## License

MIT License - See LICENSE file for details
````

## requirements.txt

- Characters: 44
- Tokens: 0

```text
PyQt6>=6.6.1
keyboard>=0.13.5
appdirs>=1.4.4
```

## src\prompt_deck\prompt_deck.py

- Characters: 15842
- Tokens: 0

```python
import sys
import json
from pathlib import Path
from typing import Dict
import webbrowser

from appdirs import user_data_dir

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout,
    QHBoxLayout, QTextEdit, QLineEdit, QPushButton,
    QLabel, QScrollArea, QFrame, QSizePolicy
)
from PyQt6.QtCore import (
    Qt, QSize
)
from PyQt6.QtGui import (
    QFont, QIcon, QColor, QPalette
)

# Use Windows 11 preinstalled fonts
FONT_FAMILY = "Segoe UI"  # Default Windows 11 system font


class ContextInput(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 2, 0, 2)
        layout.setSpacing(2)

        # Context name input
        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText("Context Name")
        self.name_input.setFont(QFont(FONT_FAMILY, 10))
        self.name_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 4px;
                background-color: #f8f8f8;
            }
            QLineEdit:focus {
                border: 1px solid #4a86e8;
                background-color: white;
            }
        """)
        layout.addWidget(self.name_input)

        # Context content input
        self.content_input = QTextEdit()
        self.content_input.setFixedHeight(80)
        self.content_input.setPlaceholderText("Context Content")
        self.content_input.setFont(QFont(FONT_FAMILY, 10))
        self.content_input.textChanged.connect(self.update_char_count)
        self.content_input.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 4px;
                background-color: #f8f8f8;
            }
            QTextEdit:focus {
                border: 1px solid #4a86e8;
                background-color: white;
            }
        """)
        layout.addWidget(self.content_input)

        # Bottom row
        bottom_row = QHBoxLayout()
        bottom_row.setSpacing(2)

        # Character count label
        self.char_count_label = QLabel("Characters: 0")
        self.char_count_label.setFont(QFont(FONT_FAMILY, 8))
        self.char_count_label.setStyleSheet("color: #666;")
        bottom_row.addWidget(self.char_count_label)

        bottom_row.addStretch()

        # Delete button
        self.delete_button = QPushButton("Remove")
        self.delete_button.setFixedWidth(80)
        self.delete_button.setFont(QFont(FONT_FAMILY, 9))
        self.delete_button.clicked.connect(self.on_delete)
        self.delete_button.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 4px;
            }
            QPushButton:hover {
                background-color: #e53935;
            }
            QPushButton:pressed {
                background-color: #d32f2f;
            }
        """)
        bottom_row.addWidget(self.delete_button)

        layout.addLayout(bottom_row)

    def on_delete(self):
        # Removes itself from its layout and the main list
        self.setParent(None)
        self.deleteLater()

    def update_char_count(self):
        count = len(self.content_input.toPlainText())
        self.char_count_label.setText(f"Characters: {count}")

    def get_data(self) -> Dict[str, str]:
        return {
            "name": self.name_input.text(),
            "content": self.content_input.toPlainText()
        }

    def set_data(self, data: Dict[str, str]):
        self.name_input.setText(data.get("name", ""))
        self.content_input.setText(data.get("content", ""))
        self.update_char_count()


class PromptDeck(QMainWindow):
    def __init__(self):
        super().__init__(None, Qt.WindowType.Window)
        self.setWindowTitle("Prompt Deck")

        # Use a system icon
        self.setWindowIcon(QIcon(QApplication.style().standardIcon(QApplication.style().StandardPixmap.SP_FileIcon)))

        # Setup UI
        self.setup_ui()
        self.load_state()

    def setup_ui(self):
        # Set the application style
        self.setStyleSheet("""
            QMainWindow {
                background-color: #f5f5f5;
            }
            QScrollArea {
                background-color: #f5f5f5;
                border: none;
            }
            QScrollBar:vertical {
                border: none;
                background: #f0f0f0;
                width: 8px;
                margin: 0px;
            }
            QScrollBar::handle:vertical {
                background: #c0c0c0;
                min-height: 20px;
                border-radius: 4px;
            }
            QScrollBar::handle:vertical:hover {
                background: #a0a0a0;
            }
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                height: 0px;
            }
        """)

        # Main widget and layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(10)

        # Main prompt
        prompt_layout = QVBoxLayout()
        prompt_layout.setSpacing(4)

        # Improved label styling
        prompt_label = QLabel("Main Prompt")
        prompt_label.setFont(QFont(FONT_FAMILY, 10, QFont.Weight.Medium))
        prompt_label.setStyleSheet("color: #333; margin-bottom: 2px;")
        prompt_layout.addWidget(prompt_label)

        # Improved text edit styling
        self.main_prompt = QTextEdit()
        self.main_prompt.setMinimumHeight(100)
        self.main_prompt.setPlaceholderText("Enter your main prompt here...")
        self.main_prompt.setFont(QFont(FONT_FAMILY, 10))
        self.main_prompt.setStyleSheet("""
            QTextEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 8px;
                background-color: #f8f8f8;
            }
            QTextEdit:focus {
                border: 1px solid #4a86e8;
                background-color: white;
            }
        """)
        prompt_layout.addWidget(self.main_prompt)

        main_layout.addLayout(prompt_layout)

        # Add a separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        separator.setStyleSheet("background-color: #e0e0e0;")
        main_layout.addWidget(separator)

        # Contexts row
        context_section = QHBoxLayout()
        context_label = QLabel("Context Sections")
        context_label.setFont(QFont(FONT_FAMILY, 10, QFont.Weight.Medium))
        context_label.setStyleSheet("color: #333;")
        context_section.addWidget(context_label)
        context_section.addStretch()

        # Improved button styling
        add_context_btn = QPushButton("Add Context")
        add_context_btn.setFixedWidth(100)
        add_context_btn.setFont(QFont(FONT_FAMILY, 9))
        add_context_btn.clicked.connect(self.add_context)
        add_context_btn.setStyleSheet("""
            QPushButton {
                background-color: #4a86e8;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 6px;
            }
            QPushButton:hover {
                background-color: #5a96f8;
            }
            QPushButton:pressed {
                background-color: #3a76d8;
            }
        """)
        context_section.addWidget(add_context_btn)

        main_layout.addLayout(context_section)

        # Scroll area
        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setFrameShape(QFrame.Shape.NoFrame)
        self.scroll.setSizePolicy(
            QSizePolicy.Policy.Expanding,
            QSizePolicy.Policy.Expanding
        )

        self.context_container = QWidget()
        self.context_container.setStyleSheet("background-color: #f5f5f5;")
        self.context_layout = QVBoxLayout(self.context_container)
        self.context_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.context_layout.setContentsMargins(0, 0, 0, 0)
        self.context_layout.setSpacing(10)

        self.scroll.setWidget(self.context_container)
        main_layout.addWidget(self.scroll)

        # Keep track of contexts
        self.contexts = []

        # Add one context by default
        self.add_context()

        # Add a separator before buttons
        separator2 = QFrame()
        separator2.setFrameShape(QFrame.Shape.HLine)
        separator2.setFrameShadow(QFrame.Shadow.Sunken)
        separator2.setStyleSheet("background-color: #e0e0e0;")
        main_layout.addWidget(separator2)

        # Button row
        button_layout = QHBoxLayout()

        # Copy to clipboard
        self.copy_btn = QPushButton("Copy to Clipboard")
        self.copy_btn.setFont(QFont(FONT_FAMILY, 10))
        self.copy_btn.clicked.connect(self.copy_to_clipboard)
        self.copy_btn.setStyleSheet("""
            QPushButton {
                background-color: #4a86e8;
                color: white;
                border: none;
                border-radius: 4px;
                padding: 8px;
            }
            QPushButton:hover {
                background-color: #5a96f8;
            }
            QPushButton:pressed {
                background-color: #3a76d8;
            }
        """)
        button_layout.addWidget(self.copy_btn)

        # LLM site shortcuts with improved styling
        self.llm_sites = {
            "ChatGPT": ("https://chat.openai.com", "#10a37f"),  # OpenAI green
            "Claude":  ("https://claude.ai", "#5436da"),        # Anthropic purple
            "Grok":    ("https://grok.x.ai", "#1DA1F2")         # Twitter blue
        }

        for name, (url, color) in self.llm_sites.items():
            btn = QPushButton(name)
            btn.setFixedWidth(80)
            btn.setFont(QFont(FONT_FAMILY, 10))
            btn.clicked.connect(lambda checked, u=url: self.launch_site(u))
            btn.setStyleSheet(f"""
                QPushButton {{
                    background-color: {color};
                    color: white;
                    border: none;
                    border-radius: 4px;
                    padding: 8px;
                }}
                QPushButton:hover {{
                    background-color: {color}dd;
                }}
                QPushButton:pressed {{
                    background-color: {color}aa;
                }}
            """)
            button_layout.addWidget(btn)

        main_layout.addLayout(button_layout)

        # Default window size
        self.resize(500, 600)

    def add_context(self):
        context = ContextInput()
        context.delete_button.clicked.connect(
            lambda: self.remove_context(context)
        )
        self.contexts.append(context)
        self.context_layout.addWidget(context)

    def remove_context(self, context):
        if context in self.contexts:
            self.contexts.remove(context)

    def copy_to_clipboard(self):
        formatted_text = self.get_formatted_text()
        clipboard = QApplication.clipboard()
        clipboard.setText(formatted_text)

    def launch_site(self, url: str):
        self.copy_to_clipboard()
        webbrowser.open(url)

    def get_formatted_text(self) -> str:
        parts = [self.main_prompt.toPlainText(), ""]

        valid_contexts = [
            c for c in self.contexts
            if c.parent() is not None and
               (c.get_data()["name"] or c.get_data()["content"])
        ]
        for context in valid_contexts:
            data = context.get_data()
            parts.extend([
                f"{data['name']}:",
                data["content"],
                ""
            ])

        return "\n".join(parts)

    def get_state(self) -> Dict:
        valid_contexts = [
            c for c in self.contexts
            if c.parent() is not None
        ]
        return {
            "main_prompt": self.main_prompt.toPlainText(),
            "contexts": [c.get_data() for c in valid_contexts],
            "geometry": {
                "x": self.x(),
                "y": self.y(),
                "width": self.width(),
                "height": self.height()
            }
        }

    def load_state(self):
        state_file = Path(user_data_dir("PromptDeck")) / "state.json"
        if state_file.exists():
            try:
                with open(state_file) as f:
                    state = json.load(f)
                # Main prompt
                self.main_prompt.setText(state.get("main_prompt", ""))

                # Remove default contexts
                for c in self.contexts:
                    c.setParent(None)
                self.contexts.clear()

                # Load from file
                for context_data in state.get("contexts", []):
                    context = ContextInput()
                    context.set_data(context_data)
                    context.delete_button.clicked.connect(
                        lambda: self.remove_context(context)
                    )
                    self.contexts.append(context)
                    self.context_layout.addWidget(context)

                # Geometry
                geometry = state.get("geometry", {})
                if geometry:
                    self.setGeometry(
                        geometry.get("x", 0),
                        geometry.get("y", 0),
                        geometry.get("width", 500),
                        geometry.get("height", 600)
                    )
            except Exception as e:
                print(f"Error loading state: {e}")

    def save_state(self):
        state_dir = Path(user_data_dir("PromptDeck"))
        state_dir.mkdir(parents=True, exist_ok=True)
        state_file = state_dir / "state.json"

        try:
            with open(state_file, "w") as f:
                json.dump(self.get_state(), f)
        except Exception as e:
            print(f"Error saving state: {e}")

    def closeEvent(self, event):
        # Save state before closing
        self.save_state()
        event.accept()


def main() -> None:
    app = QApplication(sys.argv)
    # Apply a clean modern style for the whole application
    app.setStyle("Fusion")

    # Create a custom palette for a cleaner look
    palette = QPalette()
    palette.setColor(QPalette.ColorRole.Window, QColor(245, 245, 245))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(51, 51, 51))
    palette.setColor(QPalette.ColorRole.Base, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(245, 245, 245))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(51, 51, 51))
    palette.setColor(QPalette.ColorRole.Text, QColor(51, 51, 51))
    palette.setColor(QPalette.ColorRole.Button, QColor(240, 240, 240))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(51, 51, 51))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 255, 255))
    palette.setColor(QPalette.ColorRole.Link, QColor(74, 134, 232))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(74, 134, 232))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))
    app.setPalette(palette)

    # Create and show the main window
    window = PromptDeck()
    window.show()

    sys.exit(app.exec())


if __name__ == "__main__":
    main()
```

## src\prompt_deck\__init__.py

- Characters: 208
- Tokens: 0

```python
"""Prompt Deck - A lightweight Windows utility for structuring LLM prompts."""

__version__ = "0.1.0"

from .prompt_deck import main  # noqa: F401

# def main() -> None:
#     print("Hello from prompt-deck!")
```

## src\prompt_deck\__main__.py

- Characters: 90
- Tokens: 0

```python
import sys
from prompt_deck.prompt_deck import main

if __name__ == "__main__":
    main()
```

## Statistics

- Total Files: 9
- Total Characters: 19867
- Total Tokens: 0
